<!DOCTYPE html>
<html>
<head>
	<title></title>
    <style>
    .edge{
        stroke:#999;
        stroke-width:'1px';
    }
    .node{
        /*stroke:#fff;*/
        /*stroke-width:'1px';*/
        fill:#1f77b4
    }
    </style>
</head>
<body>
    <div id="fps" style="position: absolute;top:10px;left: 90%;height: 50px;width: 100px; background: #888888;color: #fff;font-size: 40px;text-align: center">
        70
    </div>
	<div id="chartContainer" style="position: absolute; height: 100%;width:100%">
        <svg id="mySvg" width="1400" height="900" >
        </svg>
	</div>
    
	<script type="text/javascript" src="../../dist/i2d.js"></script>
    <script src="https://d3js.org/d3-collection.v1.min.js"></script>
    <script src="https://d3js.org/d3-dispatch.v1.min.js"></script>
    <script src="https://d3js.org/d3-quadtree.v1.min.js"></script>
    <script src="https://d3js.org/d3-timer.v1.min.js"></script>
    <script src="https://d3js.org/d3-force.v1.min.js"></script>

	<script type="text/javascript">
        var renderer = i2d._2DSvgRenderer('#mySvg');
        var width = 1400,height=900;
        var circles,links;


        var simulation = d3.forceSimulation()
                            .force("link", d3.forceLink().id(function(d) { return d.id; }))
                            .force("charge", d3.forceManyBody())
                            .force("center", d3.forceCenter(width / 2, height / 2));

       var data = fetch('huge_graph.json')
                .then(function(response) {

                    response.json().then(function(data) {  
                        // console.log(data);

                        var graphData = {links:[],
                                        nodes:[]}

                            for(var i=0;i<data.links.length;i=i+3){
                                graphData.links.push({source:data.links[i],target:data.links[i+1]});
                                if(graphData.nodes.indexOf(data.links[i]) === -1)
                                    graphData.nodes.push(data.links[i])
                                if(graphData.nodes.indexOf(data.links[i+1]) === -1)
                                    graphData.nodes.push(data.links[i+1]);
                            }

                            graphData.links.forEach(function(d){
                                d.source = graphData.nodes.indexOf(d.source);
                                d.target = graphData.nodes.indexOf(d.target);
                            });

                            graphData.nodes = graphData.nodes.map(function(d,i){
                                                    return {value:d,id:i};
                                                });

                        renderChart(graphData) 
                    });  
                })
                .catch(function(error) {
                }); 
        
        var group = renderer.createEl({
                    el:'group',
                    attr:{
                        transform:{
                            translate:[700,400],
                            scale:[0.4,0.4]
                        }
                    }
                });

        
        function renderChart(graph){
            
           links = group.createEls(graph.links,{
                            el:'line',
                            attr:{
                                class:'edge'
                            }
                        });
             circles = group.createEls(graph.nodes,{
                            el:'circle',
                            attr:{
                                r:5,
                                class:'node'
                            }
                        });

                 simulation
                    .nodes(graph.nodes)
                    .on("tick", ticked);
                
                simulation.force("link")
                    .links(graph.links);

        }

        function ticked(){
            circles.forEach(function(d){
                this.setAttr('cx',d.x)
                    .setAttr('cy',d.y);
            });

            links.forEach(function(d){
                this.setAttr('x1',d.source.x)
                    .setAttr('y1',d.source.y)
                    .setAttr('x2',d.target.x)
                    .setAttr('y2',d.target.y);
            })
        }

        //  var rect2 = renderer.createElement({
        //                 element:'rect',
        //                 attr:{
        //                     // x:g.dom.BBox_hit.x,
        //                     // y:g.dom.BBox_hit.y,
        //                     // width:g.dom.BBox_hit.width,
        //                     // height:g.dom.BBox_hit.height,
        //                     transform:{
        //                         // translate:[700,400],
        //                         scale:[0.4,0.4]
        //                     }
        //                 },
        //                 styles:{
        //                     'stroke-width':2,
        //                     strokeStyle:'#000000'
        //                 }
        //             });
            
            // setInterval(function(){
            //     // console.log(g.dom.BBox_hit);
            //     rect2.setAttribute('x',g.dom.BBox_hit.x)
            //         .setAttribute('y',g.dom.BBox_hit.y)
            //         .setAttribute('width',g.dom.BBox_hit.width)
            //         .setAttribute('height',g.dom.BBox_hit.height);

            // },5000)



	</script>

</body>
</html>