<!DOCTYPE html>
<html style="height: 100%;background: #1d1d1d">
<head>
	<title></title>
	<style type="text/css">
		.titleBody {
			position: absolute;
			top: 50px;
			left: 100px;
		}
		.subTitle{
			font-family: "Arial";
			font-size: 24px;
		}
		.Title {
			font-size: 36px;
		}
		.red {
			color: red;
		}
		.white {
			color: white;
		}
	</style>
</head>
<body style="height: 100%;">
<div id="myCanvas" style="height: 100%;width:100%;position: absolute;">
	<div class="titleBody">
		<div><label class="Title red"> Covid-19</label> <label class="Title white"> impact on India</label></div>
		<div class="subTitle white">at District level</div>
	</div>
</div>
<script id="vertexShader" type="x-shader/x-vertex">
    attribute vec2 a_texCoord;
    varying vec2 v_texCoord;
    void main() {
        vec2 clipSpace = a_texCoord * 2.0 - 1.0;
        gl_Position = vec4(clipSpace, 0, 1);
        v_texCoord = a_texCoord;
    }
</script>
<script id="fragmentShader" type="x-shader/x-fragment">
    precision mediump float;
    varying vec2 v_texCoord;
    uniform sampler2D u_framebuffer; uniform vec4 u_colorArr[100]; uniform float u_colorCount; uniform float u_opacity; uniform float u_offset[100];

    float remap ( float minval, float maxval, float curval ) {
        return ( curval - minval ) / ( maxval - minval );
    }

    void main() {
        float alpha = texture2D(u_framebuffer, v_texCoord.xy).a;
        if (alpha > 0.0 && alpha <= 1.0) {
            vec4 color_;
            if (alpha <= u_offset[0]) {
                color_ = u_colorArr[0];
            } else if (alpha <= u_offset[1]) {
                color_ = mix( u_colorArr[0], u_colorArr[1], remap( u_offset[0], u_offset[1], alpha ) );
            } else if (alpha <= u_offset[2]) {
                color_ = mix( u_colorArr[1], u_colorArr[2], remap( u_offset[1], u_offset[2], alpha ) );
            } else if (alpha <= u_offset[3]) {
                color_ = mix( u_colorArr[2], u_colorArr[3], remap( u_offset[2], u_offset[3], alpha ) );
            } else if (alpha <= u_offset[4]) {
                color_ = mix( u_colorArr[3], u_colorArr[4], remap( u_offset[3], u_offset[4], alpha ) );
            } else if (alpha <= u_offset[5]) {
                color_ = mix( u_colorArr[4], u_colorArr[5], remap( u_offset[4], u_offset[5], alpha ) );
            } else if (alpha <= u_offset[6]) {
                color_ = mix( u_colorArr[5], u_colorArr[6], remap( u_offset[5], u_offset[6], alpha ) );
            } else if (alpha <= u_offset[7]) {
                color_ = mix( u_colorArr[6], u_colorArr[7], remap( u_offset[6], u_offset[7], alpha ) );
            } else if (alpha <= u_offset[8]) {
                color_ = mix( u_colorArr[7], u_colorArr[8], remap( u_offset[7], u_offset[8], alpha ) );
            } else if (alpha <= u_offset[9]) {
                color_ = mix( u_colorArr[8], u_colorArr[9], remap( u_offset[8], u_offset[9], alpha ) );
            } else if (alpha <= u_offset[10]) {
                color_ = mix( u_colorArr[9], u_colorArr[10], remap( u_offset[9], u_offset[10], alpha ) );
            } else {
                color_ = vec4(0.0, 0.0, 0.0, 0.0);
            }
            color_.a = color_.a - (1.0 - u_opacity);
            if (color_.a < 0.0) {
                color_.a = 0.0;
            }
            gl_FragColor = color_;
        }
    }
</script>
<script type="text/javascript" src="../../dist/i2d.js"></script>
<script type="text/javascript" src="https://d3js.org/d3.v5.min.js"></script>

<script type="text/javascript">
let outRange = [5, 100];
function scaleFun (count) {
	return outRange[0] + (((count - activeRange[0])  / (activeRange[1] - activeRange[0])) * (outRange[1] - outRange[0]));
}

var renderer = i2d.canvasLayer('#myCanvas', {}, {});
var webglRenderer = i2d.webglLayer('#myCanvas', {
                premultipliedAlpha: false,
                depth: false,
                antialias: true,
                alpha: true,
                preserveDrawingBuffer: false
            }, {
            	enableResize: false
            });
webglRenderer.setClearColor(i2d.color.rgba(0, 0, 0, 0));

var radialGrad = i2d.canvasLayer(null,{}, {});
    radialGrad.setPixelRatio(1);
    radialGrad.setSize(100, 100);

var radialGradiant = radialGrad.createRadialGradient({
                innerCircle: { x: 50, y: 50, r: 0 },
                outerCircle: { x: 50, y: 50, r: 50 },
                mode: 'percent',
                colorStops: [{ color: 'rgba(0, 0, 0, 1.0)', value: 0 },
                    { color: 'rgba(0, 0, 0, 0)', value: 100 }]
            });

	radialGrad.createEl({
                el:'circle',
                attr:{
                    r: 50, cx: 50, cy: 50
                },
                style:{
                    fillStyle: radialGradiant
                }
            });
	radialGrad.execute();

var TextureIns = webglRenderer.TextureObject({
	    width: 100,
	    height: 100,
	    src: radialGrad
	});

var zoomInstance = i2d.behaviour.zoom();
	zoomInstance.scaleExtent([1, 15]);
	zoomInstance.zoomStart(function (event) {
	});
	zoomInstance.zoom(function (event) {
		let scale = event.transform.scale[0];
		pg.setAttr('transform', event.transform);
		imageGroup.setAttr('transform', event.transform);
		let nodes = imageGroup.children;

		gg.setStyle('lineWidth', 0.12 / scale);

		for (var i = nodes.length - 1; i >= 0; i--) {
			let d = nodes[i].data();
			let active = d.active;
			active = active <= 0 ? 0 : scaleFun(Math.sqrt(active));
			let count = scaleFun(Math.sqrt(active));

			nodes[i]
			.setAttr('width', active / scale)
			.setAttr('height', active / scale)
			.setAttr('x', d.xy[0] - ((active * 0.5) / scale))
			.setAttr('y', d.xy[1] - ((active * 0.5) / scale));
		};
	});
	zoomInstance.panExtent([[-10000, -10000], [10000, 10000]]);
	zoomInstance.zoomTarget([renderer.width / 2, renderer.height / 2]);

	webglRenderer.on('zoom', zoomInstance);

var projection = d3.geoMercator()
				   .translate([renderer.width/2, renderer.height/2])
				   .center([78.96288, 20.593684])
				   .scale([1200]);
        
var path = d3.geoPath()
		  	 .projection(projection);

var Texture = webglRenderer.TextureObject({
        width: webglRenderer.width * webglRenderer.pixelRatio,
        height: webglRenderer.height * webglRenderer.pixelRatio,
        border: 0,
        format: 'RGBA',
        type: 'UNSIGNED_BYTE',
        warpS: 'CLAMP_TO_EDGE',
        warpT: 'CLAMP_TO_EDGE',
        magFilter: 'LINEAR',
        minFilter: 'LINEAR',
        mipMap: false
    });

var renderTarget = webglRenderer.RenderTarget({
        texture: Texture
    });

var imageGroup = webglRenderer.createEl({
        el: 'group',
        attr: {
            shaderType: 'image'
        },
        // bbox: false,
        renderTarget: renderTarget,
        ctx: function (ctx) {
            ctx.enable(ctx.BLEND);
            ctx.blendEquation(ctx.FUNC_ADD);
            ctx.blendFunc(ctx.ONE, ctx.ONE_MINUS_SRC_ALPHA);
            ctx.depthMask(true);
        }
    });

var pointsHref = renderHeatMap(imageGroup);
var activeBarHref = renderBarChart(renderer, {label: 'Active', x: 100, y: renderer.height - 200});
var recoveredBarHref = renderBarChart(renderer, {label: 'Recovered', x: 100, y: renderer.height - 100});
renderLegend(renderer);

var tilesData = [{
	label: 'Confirmed', value: 0, color: '#ff3d3d'
}, {
	label: 'Active', value: 0, color: '#36a4ff'
}, {
	label: 'Recovered', value: 0, color: '#0be059'
}, {
	label: 'Death', value: 0, color: '#dba9a9'
}];
var tilesRef = renderTile(renderer, tilesData);

var pg = renderer.createEl({
	el: 'group'
});

var tooltip = renderToolTip(renderer);

var g = pg.createEl({
	el: 'group',
	bbox: false
});

var gg = pg.createEl({
	el: 'group',
	style: {
		globalAlpha: 1,
		strokeStyle: '#f00',
		lineWidth: 0.12
	},
	bbox: false
});

var meshgeome = webglRenderer.MeshGeometry();
meshgeome.setAttr('a_texCoord', {
    value: new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]),
    size: 2
});
meshgeome.setDrawRange(0, 6);

var colorGrad = [{
            color: [0, 0, 0, 0.0], offset: 0
        }, {
            color: [212, 225, 255, 0.5], offset: 0.2
        }, {
            color: [166, 255, 115, 0.8], offset: 0.45
        }, {
            color: [255, 255, 0, 1.0], offset: 0.65
        }, {
            color: [255, 0, 0, 1.0], offset: 1.0
        }];
var colorGradMap = gradientMapper(colorGrad);

var opacity = 1.0;
var colorShaderRef = webglRenderer.createShaderEl({
    fragmentShader: document.getElementById('fragmentShader').textContent,
    vertexShader: document.getElementById('vertexShader').textContent,
    uniforms: {
        u_colorArr: {
            value: colorGradMap.value,
            size: 4
        },
        u_colorCount: {
            value: colorGradMap.length.toFixed(2)
        },
        u_offset: {
            value: colorGradMap.offset,
            size: 1
        },
        u_opacity: {
            value: (0.8).toFixed(2)
        },
        u_framebuffer: {
            value: Texture
        }
    },
    geometry: meshgeome
});


var indiaMap = d3.json("https://nswamy14.github.io/geoJson/india.geo.json");
var indiancities = d3.json("https://nswamy14.github.io/geoJson/indianCitiesLatLong.json");
var covidData = d3.json("https://api.covid19india.org/districts_daily.json");
var indiaDist = d3.json("https://nswamy14.github.io/geoJson/india.district.geo.json");
var activeRange = [Infinity, -Infinity];

Promise.all([indiaMap, indiancities, covidData, indiaDist]).then(function(values) {
	let disLatLng = values[1];
	let dateBuckets = {};
	let count = 0;

	g.createEl({
		el: 'path',
		attr: {
			d: path(values[0])
		},
		style: {
			shadowBlur: 15,
			shadowColor: '#42baff',
			fillStyle: 'rgba(0, 0, 1, 1)'
		}
	});

	values[3].features.forEach(function (state) {
		gg.createEl({
			el: 'path',
			attr: {
				d: path(state)
			}
		});
	});

	for(let state in values[2].districtsDaily) {
		let state_val = values[2].districtsDaily[state]
		for(let dis in state_val) {
			let dis_val = state_val[dis];
			let disLow = dis.toLowerCase();
			dis_val.forEach(function (dt) {
				dt.visible = false;
			});
			if (disLatLng[disLow] || ( disLow === 'unknown' && disLatLng[state.toLowerCase()])) {
				let d = {
					name: disLow,
					active: 0,
					death: 0,
					confirmed: 0,
					recovered: 0
				};
				let dd = disLatLng[disLow] || disLatLng[state.toLowerCase()];
				let xy = projection([dd.longitude, dd.latitude]);
				d.xy = xy;
				
				pointsHref.push(d);

			    dis_val.forEach(function (d) {
					if (!dateBuckets[d.date]) {
						dateBuckets[d.date] = [];
					}
					d.dis = disLow;
					dateBuckets[d.date].push(d);
					if (Math.sqrt(d.active) > activeRange[1]) {
						activeRange[1] = Math.sqrt(d.active);
					}
					if (Math.sqrt(d.active) <= activeRange[0] && d.active > 0) {
						activeRange[0] = Math.sqrt(d.active);
					}
				});
			} else {
				if (dis_val[dis_val.length - 1].active > 0) {
					count += 1;
					console.log(disLow, dis_val[dis_val.length - 1].active, state);
				}
			}
		}
	}

	let dtKeys = Object.keys(dateBuckets).map(function (dt) {
		return {
			date: dt
		}
	});

	let disMap = pointsHref.data.reduce(function (p, c) {
		p[c.name] = c;
		return p;
	}, {});

	let playIndex = 0;
	function Play () {
		if (!dtKeys[playIndex]) {
			return;
		}
		let DeathCount = 0;
		let activeCount = 0;
		let recoveredCount = 0;
		let total = 0;

		let curr = dateBuckets[dtKeys[playIndex].date];
		curr.forEach(function (item) {
			if (disMap[item['dis']]) {
				disMap[item['dis']].active = item.active;
				disMap[item['dis']].confirmed = item.confirmed;
				disMap[item['dis']].deceased = item.deceased;
				disMap[item['dis']].recovered = item.recovered;
			}
		});

		let barData = curr.reduce(function (p, c) {
			total += c.confirmed;
			activeCount += c.active;
			recoveredCount += c.recovered;
			DeathCount += c.deceased;
			p.active += c.active;
			p.recovered += c.recovered;
			return p;
		}, {
			active: 0,
			recovered: 0,
			index: playIndex
		});

		tilesData[0].value = total;
		tilesData[1].value = activeCount;
		tilesData[2].value = recoveredCount;
		tilesData[3].value = DeathCount;

		tilesRef.update();
		activeBarHref.push(barData);
		recoveredBarHref.push(barData);

		pointsHref.update();
		playIndex += 1;
		setTimeout(Play, 200);
	}

	Play();
});

function gradientMapper (grad) {
    const arr = [];
    const gradLength = grad.length;
    const offSetsArray = [];

    grad.forEach(function (d) {
        arr.push(d.color[0] / 255);
        arr.push(d.color[1] / 255);
        arr.push(d.color[2] / 255);
        arr.push(d.color[3] === undefined ? 1.0 : d.color[3]);
        offSetsArray.push(d.offset);
    });
    return {
        value: new Float32Array(arr),
        length: gradLength,
        offset: new Float32Array(offSetsArray)
    };
}

function renderHeatMap (imageGroup) {
	var pointsHref = imageGroup.join([], 'image', {
		action: {
			enter: function (data) {
				this.createEls(data['image'], {
				        el: 'image',
				        attr: {
				            x: function  (d) {
				            	return d.xy[0]
				            },
				            y: function  (d) {
				            	return d.xy[1]
				            },
				            width: 0.,
				            height: 0.,
				            src: TextureIns
				        },
				        style: {
				        	opacity: 0
				        }
				    })
				.on('zoom', zoomInstance)
				.on('mousemove', function (e) {
					let d = this.data();
					tooltip(d, e);
				})
				.on('mouseout', function (e) {
					tooltip();
				});
			},
			update: function (nodes) {
				nodes['image'].forEach(function (d) {
					let active = d.active;
					active = active <= 0 ? 0 : scaleFun(Math.sqrt(active));
					// let count = active > 0 ?  : 0;
					let op = Math.log(active || 1) / 5;
					op = (op > 1.0 ? 1.0 : op);
					let scale = zoomInstance.event.transform.scale[0];
					// this.setStyle('opacity', op);
					// console.log(active, op);
					this.animateTo({
				    	duration: 100,
				    	attr: {
				    		width: active / scale,
				    		height: active / scale,
				    		x: d.xy[0] - ((active * 0.5) / scale),
				    		y: d.xy[1] - ((active * 0.5) / scale)
				    	},
				    	style: {
				    		opacity: op
				    	}
				    });
				})
			}
		}
	});
	return pointsHref;
}

function renderTile (g, data) {
	let pGroup = g.createEl({
		el: 'group',
		attr: {
			transform: {
				translate: [g.width - 600, 50]
			}
		}
	});
	var joinref = pGroup.join(data, '.tile', {
		action: {
			enter: function (data) {
				this.createEls(data['.tile'], {
				        el: 'group',
				        attr: {
				        	class: 'tile',
				        	transform: function (d, i) {
				        		return {
				        			translate: [120 * i, 40]
				        		}
				        	}
				        }
				    }).forEach(function (d) {
				    	let text = this.createEl({
							el: 'text',
							attr: {
								x: 0,
								y: 0,
								text: d.label.toUpperCase()
							},
							style: {
								fillStyle: d.color ? d.color : '#34b7eb',
								font: "15px Arial"
							}
						});

						let dom = text.node();

						this.createEl({
							el: 'text',
							attr: {
								x: dom.BBox.width / 2,
								y: 25,
								text: d.value,
								class: 'value'
							},
							style: {
								textAlign: 'center',
								fillStyle: d.color ? d.color : '#34b7eb',
								font: "18px Arial"
							}
						});
				    })
			},
			exit: function (nodes) {
				if (nodes['.tile']) {
					nodes['.tile'].remove();
				}
			},
			update: function (nodes) {
				nodes['.tile'].forEach(function (d) {
					this.fetchEl('.value').text(d.value);
				})
			}
		}
	});

	return joinref;
}

function renderBarChart (renderer, {x, y, label}) {
	var activeGrad = renderer.createLinearGradient({
		x1: 0,
		y1: 100,
		x2: 0,
		y2: 0,
		colorStops: [{
	            color: 'rgba(0, 0, 0, 0.0)', value: 0
	        }, {
	            color: '#36a4ff', value: 100
	        }]
	});
	var inactiveGrad = renderer.createLinearGradient({
		x1: 0,
		y1: 100,
		x2: 0,
		y2: 0,
		colorStops: [{
	            color: 'rgba(0, 0, 0, 0.0)', value: 0
	        }, {
	            color: '#0be059', value: 100
	        }]
	});

	var barChart = renderer.createEl({
		el: 'group',
		attr: {
			transform: {
				translate: [x, y]
			}
		}
	});

	barChart.createEl({
		el: 'text',
		attr: {
			x: 0,
			y: -50,
			text: label
		},
		style: {
			fillStyle: label === 'Active' ? '#36a4ff' : '#0be059'
		}
	});

	var barHref = barChart.join([], 'group', {
		action: {
			enter: function (data) {
				this.createEls(data['group'], {
				        el: 'group',
				        attr: {
				        }
				    }).forEach(function (d) {
				    	let val = d[label.toLowerCase()];
				    	this.createEl({
				    		el:'rect',
				    		attr: {
				    			x: d.index * 8,
				    			y: 0,
				    			width: 5,
				    			height: 0
				    		},
				    		style: {
				    			fillStyle: label === 'Active' ? activeGrad : inactiveGrad,
				    			globalAlpha: 0
				    		}
				    	}).animateTo({
				    		duration: 100,
				    		attr: {
				    			height: val / 1000,
				    			y: -val / 1000
				    		},
				    		style: {
				    			globalAlpha: 1
				    		}
				    	});
				    })
			},
			update: function (nodes) {
				
			}
		}
	});
	return barHref;
}

function renderLegend (renderer) {
	var linearGradiant = renderer.createLinearGradient({
		x1: 0,
		y1: 100,
		x2: 0,
		y2: 0,
		colorStops: [{
	            color: 'rgba(0, 0, 0, 0.0)', value: 0
	        }, {
	            color: 'rgba(212, 225, 255, 0.5)', value: 20
	        }, {
	            color: 'rgba(166, 255, 115, 0.8)', value: 45
	        }, {
	            color: 'rgba(255, 255, 0, 1.0)', value: 65
	        }, {
	            color: 'rgba(255, 0, 0, 1.0)', value: 100.0
	        }]
	});

	renderer.createEl({
		el: 'rect',
		attr: {
			x: renderer.width - 200,
			y: renderer.height - 400,
			width: 20,
			height: 300
		},
		style: {
			fillStyle: linearGradiant
		}
	});
}

function renderToolTip (renderer) {
	let g = renderer.createEl({
		el: 'g',
		attr: {
			transform: {
				translate: [0, 0]
			}
		},
		style: {
			globalAlpha: 0
		}
	});

	g.createEl({
		el: 'rect',
		attr: {
			x: 0,
			y: 0,
			width: 200,
			height: 120,
			rx: 10,
			ry: 10
		},
		style: {
			fillStyle: 'rgba(100, 100, 100, 0.5)'
		}
	});

	let tooltiphref = g.join([{
		label: 'Name',
		value: '',
		color: '#ffffff'
	}, {
		label: 'Confirmed',
		value: 0,
		color: '#ff3d3d'
	}, {
		label: 'Active',
		color: '#36a4ff',
		value: 0
	}, {
		label: 'Recovered',
		color: '#0be059',
		value: 0
	}, {
		label: 'Death',
		value: 0,
		color: '#dba9a9'
	}], '.keyValue', {
		action: {
			enter: function (data) {
				this.createEls(data['.keyValue'], {
					el: 'g',
					attr: {
						class: 'keyValue',
						transform: function (d, i) {
							return {
								translate: [25, i * 20 + 20]
							}
						}
					},
					style: {
						fillStyle: function (d) {
							return d.color;
						}
					}
				}).forEach(function (d) {
					this.createEl({
						el: 'text',
						attr: {
							x: 0,
							y: 0,
							text: d.label,
							class: 'label'
						},
						style: {
							font: '15px Arial'
						}
					});

					this.createEl({
						el: 'text',
						attr: {
							x: 80,
							y: 0,
							text: d.value,
							class: 'value'
						},
						style: {
							font: '15px Arial'
						}
					});
				})
			},
			update: function (nodes) {
				nodes['.keyValue'].forEach(function (d) {
					this.fetchEl('.value').text(d.value);
				});
			}
		}
	})

	return function updateToolTip (data, pos) {
		if (arguments.length === 0) {
			g.setStyle('globalAlpha', 0);
			return;
		}
		g.setStyle('globalAlpha', 1);
		tooltiphref.join([{
			label: 'Name',
			value: data.name
		}, {
			label: 'Confirmed',
			value: data.confirmed
		}, {
			label: 'Active',
			value: data.active
		}, {
			label: 'Recovered',
			value: data.recovered
		}, {
			label: 'Death',
			value: data.deceased
		}]);

		g.setAttr('transform', {
			translate: [pos.offsetX, pos.offsetY]
		});
	};
}

</script>

</body>
</html>

