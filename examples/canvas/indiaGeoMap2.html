<!DOCTYPE html>
<html style="height: 100%;background: #1d1d1d">
<head>
	<title></title>
	<style type="text/css">
		.titleBody {
			position: absolute;
			top: 50px;
			left: 100px;
		}
		.subTitle{
			font-size: 24px;
		}
		.Title {
			font-size: 36px;
		}
		.red {
			color: red;
		}
		.white {
			color: white;
		}
	</style>
</head>
<body style="height: 100%;">
<div id="myCanvas" style="height: 100%;width:100%;position: absolute;">
	<div class="titleBody">
		<div><label class="Title red"> Covid-19</label> <label class="Title white"> impact on India</label></div>
		<div class="subTitle white">at District level</div>
	</div>
</div>
<script src="https://unpkg.com/topojson@3"></script>
<script id="vertexShader" type="x-shader/x-vertex">
    attribute vec2 a_texCoord;
    varying vec2 v_texCoord;
    void main() {
        vec2 clipSpace = a_texCoord * 2.0 - 1.0;
        gl_Position = vec4(clipSpace, 0, 1);
        v_texCoord = a_texCoord;
    }
</script>
<script id="fragmentShader" type="x-shader/x-fragment">
    precision mediump float;
    varying vec2 v_texCoord;
    uniform sampler2D u_framebuffer; uniform vec4 u_colorArr[100]; uniform float u_colorCount; uniform float u_opacity; uniform float u_offset[100];

    float remap ( float minval, float maxval, float curval ) {
        return ( curval - minval ) / ( maxval - minval );
    }

    void main() {
        float alpha = texture2D(u_framebuffer, v_texCoord.xy).a;
        if (alpha > 0.0 && alpha <= 1.0) {
            vec4 color_;
            if (alpha <= u_offset[0]) {
                color_ = u_colorArr[0];
            } else if (alpha <= u_offset[1]) {
                color_ = mix( u_colorArr[0], u_colorArr[1], remap( u_offset[0], u_offset[1], alpha ) );
            } else if (alpha <= u_offset[2]) {
                color_ = mix( u_colorArr[1], u_colorArr[2], remap( u_offset[1], u_offset[2], alpha ) );
            } else if (alpha <= u_offset[3]) {
                color_ = mix( u_colorArr[2], u_colorArr[3], remap( u_offset[2], u_offset[3], alpha ) );
            } else if (alpha <= u_offset[4]) {
                color_ = mix( u_colorArr[3], u_colorArr[4], remap( u_offset[3], u_offset[4], alpha ) );
            } else if (alpha <= u_offset[5]) {
                color_ = mix( u_colorArr[4], u_colorArr[5], remap( u_offset[4], u_offset[5], alpha ) );
            } else if (alpha <= u_offset[6]) {
                color_ = mix( u_colorArr[5], u_colorArr[6], remap( u_offset[5], u_offset[6], alpha ) );
            } else if (alpha <= u_offset[7]) {
                color_ = mix( u_colorArr[6], u_colorArr[7], remap( u_offset[6], u_offset[7], alpha ) );
            } else if (alpha <= u_offset[8]) {
                color_ = mix( u_colorArr[7], u_colorArr[8], remap( u_offset[7], u_offset[8], alpha ) );
            } else if (alpha <= u_offset[9]) {
                color_ = mix( u_colorArr[8], u_colorArr[9], remap( u_offset[8], u_offset[9], alpha ) );
            } else if (alpha <= u_offset[10]) {
                color_ = mix( u_colorArr[9], u_colorArr[10], remap( u_offset[9], u_offset[10], alpha ) );
            } else {
                color_ = vec4(0.0, 0.0, 0.0, 0.0);
            }
            color_.a = color_.a - (1.0 - u_opacity);
            if (color_.a < 0.0) {
                color_.a = 0.0;
            }
            gl_FragColor = color_;
        }
    }
</script>
<script type="text/javascript" src="../../dist/i2d.js"></script>
<script type="text/javascript" src="https://d3js.org/d3.v5.min.js"></script>

<script type="text/javascript">
var colorGrad = [{
            color: [0, 0, 0, 0.0], offset: 0
        }, {
            color: [212, 225, 255, 0.5], offset: 0.2
        }, {
            color: [166, 255, 115, 0.8], offset: 0.45
        }, {
            color: [255, 255, 0, 1.0], offset: 0.65
        }, {
            color: [255, 0, 0, 1.0], offset: 1.0
        }];
var colorGradMap = gradientMapper(colorGrad);

var renderer = i2d.canvasLayer('#myCanvas', {}, {});
var webglRenderer = i2d.webglLayer('#myCanvas', {
                premultipliedAlpha: false,
                depth: false,
                antialias: true,
                alpha: true,
                preserveDrawingBuffer: false
            }, {
            	enableResize: false
            });
webglRenderer.setClearColor(i2d.color.rgba(0, 0, 0, 0));

var radialGrad = i2d.canvasLayer(null,{}, {});
    radialGrad.setPixelRatio(1);
    radialGrad.setSize(100, 100);

var radialGradiant = radialGrad.createRadialGradient({
                innerCircle: { x: 50, y: 50, r: 0 },
                outerCircle: { x: 50, y: 50, r: 50 },
                mode: 'percent',
                colorStops: [{ color: 'rgba(0, 0, 0, 1.0)', value: 0 },
                    { color: 'rgba(0, 0, 0, 0)', value: 100 }]
            });

	radialGrad.createEl({
                el:'circle',
                attr:{
                    r: 50, cx: 50, cy: 50
                },
                style:{
                    fillStyle: radialGradiant
                }
            });
	radialGrad.execute();

var TextureIns = webglRenderer.TextureObject({
	    width: 100,
	    height: 100,
	    src: radialGrad
	});

var zoomInstance = i2d.behaviour.zoom();
	zoomInstance.scaleExtent([1, 15]);
	zoomInstance.zoomStart(function (event) {
	});
	zoomInstance.zoom(function (event) {
		let scale = event.transform.scale[0];
		pg.setAttr('transform', event.transform);
		imageGroup.setAttr('transform', event.transform);
		let nodes = imageGroup.children;

		gg.setStyle('lineWidth', 0.2 / scale);

		for (var i = nodes.length - 1; i >= 0; i--) {
			let d = nodes[i].data();
			let active = d.active <= 1 ? 1 : d.active;
			let count = Math.log10(active) * 10;

			nodes[i]
			.setAttr('width', count / scale)
			.setAttr('height', count / scale)
			.setAttr('x', d.xy[0] - ((count * 0.5) / scale))
			.setAttr('y', d.xy[1] - ((count * 0.5) / scale));
		};
	});
	zoomInstance.panExtent([[-10000, -10000], [10000, 10000]]);
	zoomInstance.zoomTarget([renderer.width / 2, renderer.height / 2]);

	webglRenderer.on('zoom', zoomInstance);

var projection = d3.geoMercator()
				   .translate([renderer.width/2, renderer.height/2])
				   .center([78.96288, 20.593684])
				   .scale([1200]);
        
var path = d3.geoPath()
		  	 .projection(projection);

var Texture = webglRenderer.TextureObject({
        width: webglRenderer.width * webglRenderer.pixelRatio,
        height: webglRenderer.height * webglRenderer.pixelRatio,
        border: 0,
        format: 'RGBA',
        type: 'UNSIGNED_BYTE',
        warpS: 'CLAMP_TO_EDGE',
        warpT: 'CLAMP_TO_EDGE',
        magFilter: 'LINEAR',
        minFilter: 'LINEAR',
        mipMap: false
    });

var renderTarget = webglRenderer.RenderTarget({
        texture: Texture
    });

var imageGroup = webglRenderer.createEl({
        el: 'group',
        attr: {
            shaderType: 'image'
        },
        // bbox: false,
        renderTarget: renderTarget,
        ctx: function (ctx) {
            ctx.enable(ctx.BLEND);
            ctx.blendEquation(ctx.FUNC_ADD);
            ctx.blendFunc(ctx.ONE, ctx.ONE_MINUS_SRC_ALPHA);
            ctx.depthMask(true);
        }
    });

var pointsHref = imageGroup.join([], 'image', {
	action: {
		enter: function (data) {
			this.createEls(data['image'], {
			        el: 'image',
			        attr: {
			            x: function  (d) {
			            	return d.xy[0]
			            },
			            y: function  (d) {
			            	return d.xy[1]
			            },
			            width: 0.,
			            height: 0.,
			            src: TextureIns
			        },
			        style: {
			        	opacity: 0
			        }
			    }).on('mouseover', function (e) {
			    	console.log(this.data());
			    });
		},
		update: function (nodes) {
			nodes['image'].forEach(function (d) {
				let active = d.active;
				active = active <= 1 ? 1 : active;
				let count = Math.log10(active) * 10;
				let op = Math.log(active) / 10;
				op = (op > 1.0 ? 1.0 : op);
				let scale = zoomInstance.event.transform.scale[0];
				// this.setStyle('opacity', op);
				this.animateTo({
			    	duration: 100,
			    	attr: {
			    		width: count / scale,
			    		height: count / scale,
			    		x: d.xy[0] - ((count * 0.5) / scale),
			    		y: d.xy[1] - ((count * 0.5) / scale)
			    	},
			    	style: {
			    		opacity: op
			    	}
			    });
			})
		}
	}
});

var pg = renderer.createEl({
	el: 'group'
});

var barChart = renderer.createEl({
	el: 'group',
	attr: {
		transform: {
			translate: [100, 600]
		}
	}
});

var barHref = barChart.join([], 'group', {
	action: {
		enter: function (data) {
			this.createEls(data['group'], {
			        el: 'group',
			        attr: {
			        }
			    }).forEach(function (d) {
			    	this.createEl({
			    		el:'rect',
			    		attr: {
			    			x: d.index * 7,
			    			y: 0,
			    			width: 5,
			    			height: 0
			    		},
			    		style: {
			    			fillStyle: '#f00'
			    		}
			    	}).animateTo({
			    		duration: 100,
			    		attr: {
			    			height: d.active / 1000,
			    			y: -d.active / 1000
			    		}
			    	});

			    	this.createEl({
			    		el:'rect',
			    		attr: {
			    			x: d.index * 7,
			    			y: 0,
			    			width: 5,
			    			height: 0
			    		},
			    		style: {
			    			fillStyle: '#42baff'
			    		}
			    	}).animateTo({
			    		duration: 100,
			    		attr: {
			    			height: d.recovered / 1000
			    		}
			    	});
			    })
		},
		update: function (nodes) {
			
		}
	}
});

var linearGradiant = renderer.createLinearGradient({
	x1: 0,
	y1: 100,
	x2: 0,
	y2: 0,
	colorStops: [{
            color: 'rgba(0, 0, 0, 0.0)', value: 0
        }, {
            color: 'rgba(212, 225, 255, 0.5)', value: 20
        }, {
            color: 'rgba(166, 255, 115, 0.8)', value: 45
        }, {
            color: 'rgba(255, 255, 0, 1.0)', value: 65
        }, {
            color: 'rgba(255, 0, 0, 1.0)', value: 100.0
        }]
});

renderer.createEl({
	el: 'rect',
	attr: {
		x: renderer.width - 200,
		y: renderer.height - 400,
		width: 20,
		height: 300
	},
	style: {
		fillStyle: linearGradiant
	}
});

var g = pg.createEl({
	el: 'group',
	bbox: false
});
var gg = pg.createEl({
	el: 'group',
	style: {
		globalAlpha: 1,
		strokeStyle: '#f00',
		lineWidth: 0.2
	},
	bbox: false
});

var meshgeome = webglRenderer.MeshGeometry();
meshgeome.setAttr('a_texCoord', {
    value: new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]),
    size: 2
});
meshgeome.setDrawRange(0, 6);

var opacity = 1.0;
var colorShaderRef = webglRenderer.createShaderEl({
    fragmentShader: document.getElementById('fragmentShader').textContent,
    vertexShader: document.getElementById('vertexShader').textContent,
    uniforms: {
        u_colorArr: {
            value: colorGradMap.value,
            size: 4
        },
        u_colorCount: {
            value: colorGradMap.length.toFixed(2)
        },
        u_offset: {
            value: colorGradMap.offset,
            size: 1
        },
        u_opacity: {
            value: (0.8).toFixed(2)
        },
        u_framebuffer: {
            value: Texture
        }
    },
    geometry: meshgeome
});


var indiaMap = d3.json("https://nswamy14.github.io/geoJson/india.geo.json");
var indiancities = d3.json("./../data/indianCities.json");
var covidData = d3.json("https://api.covid19india.org/districts_daily.json");
var indiaDist = d3.json("https://nswamy14.github.io/geoJson/india.district.geo.json");

Promise.all([indiaMap, indiancities, covidData, indiaDist]).then(function(values) {
	let disLatLng = values[1];
	let dateBuckets = {};
	let count = 0;

	for(let state in values[2].districtsDaily) {
		let state_val = values[2].districtsDaily[state]
		for(let dis in state_val) {
			let dis_val = state_val[dis];
			let disLow = dis.toLowerCase();
			dis_val.forEach(function (dt) {
				dt.visible = false;
			});
			if (disLatLng[disLow] || disLatLng[state.toLowerCase()]) {
				let d = {
					name: disLow,
					active: 0
				};
				let dd = disLatLng[disLow] || disLatLng[state.toLowerCase()];
				let xy = projection([dd.longitude, dd.latitude]);
				d.xy = xy;
				
				pointsHref.push(d);

			    dis_val.forEach(function (d) {
					if (!dateBuckets[d.date]) {
						dateBuckets[d.date] = [];
					}
					d.dis = disLow;
					dateBuckets[d.date].push(d);
				})
			} else {
				// if (dis_val[dis_val.length - 1].active > 0) {
				// 	count += 1;
				// 	// console.log(disLow, dis_val[dis_val.length - 1].active, state);
				// }
			}
		}
	}

	g.createEl({
		el: 'path',
		attr: {
			d: path(values[0])
		},
		style: {
			shadowBlur: 15,
			shadowColor: '#42baff',
			fillStyle: 'rgba(0, 0, 1, 1)'
		}
	});

	values[3].features.forEach(function (state) {
		gg.createEl({
			el: 'path',
			attr: {
				d: path(state)
			}
		});
	});

	let dtKeys = Object.keys(dateBuckets).map(function (dt) {
		return {
			date: dt
		}
	});

	let disMap = pointsHref.data.reduce(function (p, c) {
		p[c.name] = c;
		return p;
	}, {});

	let playIndex = 0;
	function Play () {
		if (!dtKeys[playIndex]) {
			return;
		}
		let curr = dateBuckets[dtKeys[playIndex].date];
		curr.forEach(function (item) {
			if (disMap[item['dis']]) {
				disMap[item['dis']].active = item.active;
			}
		});

		let barData = curr.reduce(function (p, c) {
			p.active += c.active;
			p.recovered += c.recovered;
			return p;
		}, {
			active: 0,
			recovered: 0,
			index: playIndex
		});

		barHref.push(barData);

		pointsHref.update();
		playIndex += 1;
		setTimeout(Play, 200);
	}

	Play();
});

function gradientMapper (grad) {
    const arr = [];
    const gradLength = grad.length;
    const offSetsArray = [];

    grad.forEach(function (d) {
        arr.push(d.color[0] / 255);
        arr.push(d.color[1] / 255);
        arr.push(d.color[2] / 255);
        arr.push(d.color[3] === undefined ? 1.0 : d.color[3]);
        offSetsArray.push(d.offset);
    });
    return {
        value: new Float32Array(arr),
        length: gradLength,
        offset: new Float32Array(offSetsArray)
    };
}
</script>

</body>
</html>

